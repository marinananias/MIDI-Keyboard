# MIDI-Keyboard
Functional virtual keyboard that allows users to play music using their mouse.

# REFLECTION
The MIDI Keyboard was a collaborative effort between myself, Maya, and Anthony for our CSC-151 final project. Our task was to build a functional virtual keyboard that would allow users to play music using their mouse. The keyboard features various buttons on the side that allow users to change functions and produce different sounds,  including random, major, minor, guitar, percussion, wind, and standard piano. We built this project to provide an interactive and user-friendly way for music enthusiasts to create and experiment with different tunes.

Regarding the architecture of the project, our group broke it down into different components, which included the sound, visual, and functional parts. Each team member was responsible for contributing to one or more of these components. In terms of my contribution to the project, while I participated in the debugging process of other parts of the code with Anthony and Maya, I primarily worked on the sound component. Specifically, I contributed to this component by writing a substantial amount of code to create different sounds and a total of six lists of compositions for each button on the keyboard.

One of the most significant challenges I faced during the project was a bug that I encountered while using the "instrument" function from the music library, which had incomplete documentation. Initially, I observed that the function was not working correctly and was not producing the desired sounds. To fix this issue, I tried different syntax arrangements of the function along with "map" and a list of compositions. It took several attempts of the "diagnose/fix" cycle before finding a solution that worked. The first discovery was that I needed to use "mod" with "instrument" for the function to work correctly. The second discovery happened after I stopped getting error messages but was still not getting the desired result. I realized that I needed to be in the newest version of Scamper to use the "instrument" function.

Looking back, to avoid introducing this bug in the first place, I should have thoroughly tested the "instrument" function before incorporating it into the code. I also learned that when using a new library or function, it is essential to ensure that all components are compatible with the version being used.

Another difficulty faced during the project was deciding on sound design choices. While this may seem like a minor issue, it was a significant challenge that required careful consideration. We had to choose between using lists, dictionaries, vectors, or pairs to implement the sound component. Each of these options had its advantages and disadvantages, and we had to consider how they would impact the overall project's functionality. I tried out different approaches, but after discussing the issue with my partners, we decided to use lists. This choice made it easier to access the compositions and integrate them with the visual part of the code. Additionally, we had to adapt the sound part to what we could do with the visual, like reducing the mode inventory and input from seven to two.
